ЗАМЕТКИ

урок 17.
1.Middlewa//Middleware для санок есть
под капотом(т.е. можно не писать), но нужно будет настраивать, если понадобятся какие-либо еще Middlewarere для санок
есть

2. в slice стейт типизируется автоматически

домашка:

1/ зануление и правильная подгрузка тасок и тудулистов при выходе из приложения

* подгрузка тасок теперь не из компоненты todolist, а из санки fetchTodolistsTC, т.е. только после полной загрузки
  тудулистов
* добавлен подредьюсер удаления тасок и тудулистов при логауте (clearTodosData)

2/ добавление селекторов

Обычные селекторы:
const all = state => state.cart
const items = state => all(state).items
const calculation = state => all(state).calculation
const bonuses = state => calculation(state).bonuses

Такие селекторы стоит использовать всегда, когда мы напрямую ссылаемся на данные из стора. Даже если возвращаемое
значение является объектом, не стоит беспокоиться - мы лишь возвращаем ссылку на уже существующий объект, который
находится в стейте, так что ни к каким проблемам это не приведет.

Мемоизированные селекторы в подобных случаях использовать не стоит — из-за проверки входных данных и сравнения их с
предыдущими, такие селекторы будут медленнее (~ в 30 раз в последнем Chrome), а объем занимаемой памяти увеличится, так
как предыдущие входные данные нужно где-то хранить. Проблема с памятью не очень заметна, но становится вполне ощутима,
когда входными данными является объект с множеством данных.

Соблюдайте основные правила с селекторами:
1.Выносите селекторы в отдельный слой (например на уровне модуля) и далее используйте их в остальных участках
приложения.

2.Объединяйте селекторы в объект (namespace), чтобы избежать повторений кода и конфликтов имен. Лучше всего для этого
подходит ре-экспорт.

3.Не рассчитывайте на useSelector в плане оптимизаций. Он лишь предотвращает ререндер, если сравнение результата через
=== вернуло true.

Используйте обычные селекторы без мемоизации когда:
1.Нужно просто достать значение из стора.

2.(не обязательно) Нужно сделать простую операцию между какими-то значениями, при этом результатом этой операции
является
примитив.

Используйте мемоизированные селекторы когда:
1.В селекторе есть тяжелые вычисления (фильтрация, сортировка, сложное преобразование данных, и так далее).

2.Результатом вызова селектора является объект. Ну и конечно же, это касается массивов и различных структур вроде Set и
Map, так как они тоже являются объектами.

урок 18 (подготовка)

добавлена санка createAsyncThunk в файле auth.reducer.ts

TC нужен, чтобы создать замыкание и передать санке нужные данные

!!!При создании createAsyncThunk помимо TC создаются еще 2 AC - 1 выполнится, когда все хорошо, а другой выполнится, когда
все будет плохо.

ExtraReducers позволяет написать обработчик какого-либо экшена, не создавая AC. Это нужно для экшена со стороны, который
уже
создан в каком-то другом редьюсере. Также в ExtraReducers нужно обрабатывать AC, созданные автоматически в TC,
написанных
через createAsyncThunk.

Автоматически созданный из createAsyncThunk AC будет содержать в себе как payload то, что мы вернем из санки.

остановилась на 58 мин 1 видео 18 урока! 